/* 
 * Data Analytics Application Profiling API
 *
 * A simplifying and abstracting usercode-oriented library that 
 * provides the means for codes running on HPC cluster compute nodes
 * to log messages to a logfile on an external system -
 * at LANL this is the Tivan Data Analytics system.
 * From the external system, logs can be analyzed (to see if a code is 
 * still progressing normally, for instance).
 *
 * The API provided here does not do the transfer to the Analytics system
 * itself; instead it communicates with the thing (message broker, syslog, 
 * LDMSD, point-to-point communicator, or whatever else) that does the 
 * transfer off the cluster and then gets the data to a place where it
 * can be accessed from the Data Analytics system.
 *
 * Also provides a function to create formatted JSON for a later insert
 * as a row in a remote timeseries database
 * (in the LANL case, OpeTSDB, and again, residing on Tivan) 
 * assuming the row is correctly formatted. This data can then 
 * be visualized using Grafana on the Analytics system. 
 *
 * Users should be made aware that if the row is *not* correctly 
 * formatted or if there is some other problem with the data,
 * the failure to insert may be a silent one. This is because the 
 * attempt to insert into the database is an independent process 
 * that happens after data has moved off of compute nodes, with no
 * link back to the user process that created the data using this library.
 * 
 * The actual means by which log messages (or database rows) make it off
 * the compute cluster and into the external analytics system are hidden 
 * from the user by this library. 
 *
 * Header file: daap_log.h
 * Shared library: libdaap_log.so
 * Static library: libdaap_log.a
 *
 * Functions:
 *****************
 * daapInit(const char *app_name, int level)
 *   Populates some global variables with initialized information
 *   using the function parameters and data specific to the node/job,
 *   like hostname and job_id. 
 *
 * daapLogWrite(const char *message, int keyval, ...)
 *
 *   Logs <message> (followed by escape/control arguments) to a logfile
 *   (at present, syslog) with priority of <level> that is transmitted
 *   to the remote monitoring system (Tivan at LANL). <app_name> is a 
 *   user-defined string that is prepended to the message - normally this
 *   would be the name of the calling application but it is at the user's
 *   discretion. <keyval> is an integer key-value that may be used later 
 *   when searching through the logs. It is prepended to the message. 
 *
 *   ***Note that daapLogWrite is subject to the same format string
 *   vulnerabilities/attacks as printf() and is not intended to be used by
 *   untrusted callers.
 *
 *****************
 * daapLogRead(int keyval, int time_interval)
 *
 *   Placeholder. Would provide the ability to read messages that 
 *   have been written by the application, **local to the node that is 
 *   calling the function**. Will be further developed if demand exists.
 *
 *****************
 * daapFinalize(void)
 *   Cleans up / depopulates / dallocates (as required) structures 
 *   populated by daapInit. 
 * }
 *****************
 * daapMetricCreate(metric_t metric, int numTags, char *tagArray)
 *
 *   Initializes the combination of a named metric and a number of named tags
 *   (up to 10). Values for the metric and tags are then specified in each
 *   call to daapMetricWrite().
 *   
 *   By setting up this combination of metric and tags ahead of time, it
 *   reduces the likelihood of many inserts of rows with different tags
 *   (that should actually be the same) into the downstream database.
 *
 * daapMetricWrite(metric_t metric, char *value, int numTags, 
 *                   char *tag1, char *tag1val, ...)
 *
 *   Writes out JSON in a format consistent with that necessary
 *   to insert rows into a timeseries database (in the case of LANL, 
 *   this remote TSDB is OpenTSDB on Tivan). Does some checking to 
 *   try to verify that data can be inserted as a valid row in the
 *   database.
 *
 * daapMetricDestroy(void) 
 *
 *   Frees any memory that was allocated by 
 *   daapMetricCreate() and removes the association between the metric_id
 *   and the metric_name.
 ******************
 *
 *   While some format checking will be done, it is ultimately the
 *   responsibility of the caller to ensure that the metric, value, and tags
 *   are useful and well-formatted so that they will successfully insert
 *   into the database and so they can later be queried and visualized. 
 *   Because data must transfer off the cluster and pass through 
 *   a message broker prior to insertion into the database, no immediate
 *   feedback on whether the insertion succeeded or failed shoud be
 *   expected, either now or in the future.
 *   In addition to the user-defined tags, hostname (and possibly cpu ID)
 *   will also be written as tags to each row entry. 
 *   The metric_t type defines a struct that, in addition to metric
 *   information, also contains values for the hostname and cpu ID after
 *   a successful return from daapTsdbCreateMetric.
 *
 * Copyright (C) 2020 Triad National Security, LLC. All rights reserved.
 * Original author: Charles Shereda, cpshereda@lanl.gov
 */

#include "daap_log.h"

#if defined USE_SYSLOG
#    if defined __APPLE__
#        include <os/log.h>
#        include <pwd.h>
#    else
#        include <syslog.h>
#    endif
#elif defined USE_RABBIT

#elif defined USE_LDMS

#elif defined USE_P2P

#endif

#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdarg.h>

//static bool volatile first_pass = true;

static pthread_mutex_t gethost_mutex = PTHREAD_MUTEX_INITIALIZER;

#if defined __APPLE__ 
#    define SYSLOGGER(level, args...) os_log(level, args)
#else
#    define SYSLOGGER(level, args...) vsyslog(level, args)
#endif

#define LOCAL_MAXHOSTNAMELEN 257

#ifndef HOST_NAME_MAX
#define HOST_NAME_MAX 256
#endif

#if (HOST_NAME_MAX > LOCAL_MAXHOSTNAMELEN)
#define LOCAL_MAXHOSTNAMELEN HOST_NAME_MAX
#endif

#define NUM_TRIES_FOR_NULL_HOSTNAME 8

static char daap_hostname[LOCAL_MAXHOSTNAMELEN];

/* global declaration of init_t struct init_data, initialized by daapInit(),
 * finalized in daapFinalize(), and accessed by the *Write() functions. */
init_t init_data;

/*
 * This gethostname wrapper does not populate the full-length hostname in
 * those rare cases where it is too long for the buffer. It does, however,
 * guarantee a null-terminated hostname is place in daap_hostname, even if it's
 * truncated. It also tries again in the case where gethostname returns an
 * error because the buffer is initially too short.
 */
static int daap_gethostname(char *hostname) {

    size_t count, length = LOCAL_MAXHOSTNAMELEN;
    int ret_val, num_tries = 0;

    /* thread safe */
    mutex_lock(&gethost_mutex);

    char *buf = calloc( 1, length );
    if( buf == NULL ) {
        mutex_unlock(&gethost_mutex);
        return DAAP_ERROR_OUT_OF_MEMORY;
    }

    while( num_tries < NUM_TRIES_FOR_NULL_HOSTNAME) {
        num_tries++;

        /*
         * Offer all but the last byte of the buffer to gethostname.
         */
        ret_val = gethostname( buf, length - 1 );
        /*
         * Terminate the buffer in the last position.
         */
        buf[length - 1] = '\0';
        if( ret_val == 0 ) {
            count = strlen( buf );
            /* The result was not truncated */
            if( count > 0 && count < length - 1 ) {
                /*
                 * If we got a good result, save it.  This value may
                 * be longer than what callers to local_gethostname()
                 * are expecting, so that should be checked by the
                 * caller.
                 */
                hostname = buf;
                mutex_unlock(&gethost_mutex);
                return DAAP_SUCCESS;
            }
            /*
             * count = 0: The buffer is empty. In some gethostname
             *             implementations, this can be because the
             *             buffer was too small.
             * count == (length-1): The result *may* be truncated;
             *                      we can't know for sure and 
             *                      should resize the buffer.
             *
             * If it's one of these cases, we'll fall through to
             * increase the length of the buffer and try again.
             *
             * If it's not one of these good cases, it's an error:
             * return.
             */
            else if( !(count == 0 || count == length - 1) ) {
                free(buf);
                mutex_unlock(&gethost_mutex);
                return DAAP_ERROR;
            }
        }
        /*
         * errno == EINVAL or ENAMETOOLONG: hostname was truncated and
         *              there was an error. Perhaps there is something
         *              in the buffer and perhaps not.
         *
         * If it's one of these cases, we'll fall through to
         * increase the length of the buffer and try again.
         *
         * If it's not one of these good cases, it's an error; return.
         */
        else if( !(errno == EINVAL || errno == ENAMETOOLONG) ) {
            free(buf);
            mutex_unlock(&gethost_mutex);
            return DAAP_ERROR_IN_ERRNO;
        }

        /*
         * If we get here, it means we want to double the length of
         * the buffer and try again.
         */
        length *= 2;
        buf = realloc(buf, length);
        if( buf == NULL ) {
            mutex_unlock(&gethost_mutex);
            return DAAP_ERROR_OUT_OF_MEMORY;
        }
    } /* end while */

    /* If we got here, it means that we tried too many times and are
     * giving up. */
    free(buf);
    mutex_unlock(&gethost_mutex);
    return DAAP_ERROR;
}

/* Initializer for library. */
int daapInit(const char *app_name, int msg_level, int agg_type) {
    // Might need to be thread safe. What happens if two openmp
    // threads enter this at the same time when we are using a global
    // struct to hold the initialized data?

    int ret_val = 0;

    /* allocate memory for and populate init_data.hostname with the 
     * hostname by calling daap_gethostname().*/
    ret_val = daap_gethostname(init_data.hostname);
    if( ret_val != 0 ) {
        // set errno?
        // fprintf(stderr, something); Depending on debug level??
        return ret_val;
    }
 
    /* copy the user-provided name of the app into init_data */
    strcpy(init_data.appname, app_name);
    /* if we are using syslog, open the log with the user-provided msg_level */
    openlog (init_data.appname, LOG_PERROR | LOG_CONS | LOG_PID | LOG_NDELAY, LOG_USER);
}

/* Free memory from allocated components of init_data */
int daapFinalize(void) {
    // Likely needs to be thread safe
    int ret_val = 0;
    free(init_data.hostname);
    free(init_data.appname);
    return ret_val;
}

/* Why do we need a separate daapMetricCreate?
 * Logically it's not absolutely necessary; however, it helps the user 
 * to think about each set of metric + tag names as a bundle that can't
 * be modified, so that they aren't messing up the database with changing
 * metrics and tag names in cases where they should really be constant.
 * However, there is also a downside; if there were no daapMetricCreate(),
 * the metric struct would not need to be exposed to the user. So whether
 * we have this or not is still an open question. */
int daapMetricCreate(metric_t *metric, char *metricname, int num_tags, char *tagnames[10]) {
    // Likely needs to be thread safe 
    int ret_val;

    // It's possible that the best way to do this is not by having the user
    // pass the metric struct, since this could complicate things for them
    // But if the user doesn't pass the struct in, they will still have to 
    // use 
    if( metricname[0] == '\0' ) {
        // set errno?
        // fprintf(stderr, something);
        return -1;
    }
    // need more error checking here (eg, if metric_name isn't null-terminated)

    else {
        strcpy(metric.metric_name, metricname);
    }
    /* Add logic for setting up different transport layers that isn't already
       covered by daapInit() */

    /* Populate tag_name's in metric.tag_array with the incoming tagnames[]
     * vals, using num_tags and checking for improperly terminated values */

    return 0;
}


int daapMetricDestroy(metric_t metric) {
    /* needs to be thread safe */
    return 0;
}
int daapMetricWrite(metric_t metric, char *value, int numTags, 
                      char *tag1, char *tag2, char *tag3, ...) {
    /* needs to be thread safe */
    return 0;
}

// This function doesn't buy us much since it will have to be wrapped in
// a preprocessor macro to prevent errors if we aren't using syslog. 
// We might not use it at all.
static int daapSyslogWrite(const char *app_name, int level, int keyval, const char *message, ...) {
    /* needs to be thread safe */
    va_list args;
//    setlogmask (LOG_UPTO (LOG_NOTICE));
#if defined DEBUG
    openlog (app_name, LOG_PERROR | LOG_CONS | LOG_PID | LOG_NDELAY, LOG_USER);
    va_start(args, message);
    vprintf (message, args);
    va_end(args);
#else
    openlog (app_name, LOG_NDELAY | LOG_PID, LOG_USER);
#endif
    va_start(args, message);
    SYSLOGGER(level, message, args);
    va_end(args);
    closelog ();
    return 0;
}

/* Function to write out a string to the log. Log can mean syslog or a direct
 * connection to a message broker (RabbitMQ, LDMS Streams, or a point-to-point
 * user process, or we can just aggregate with this and write only when the
 * threshold is reached. The method used is selected at build time by setting the 
 * appropriate macro (an option in CMake). 
 * The string is prepended with some syslog-type info, whether or not
 * syslog is the transport mechanism - application name, message level, and
 * hostname, for instance. */
int daapLogWrite(const char *app_name, int level, int keyval, const char *message, ...) {
    /* probably needs to be thread safe; or at least, callees 
     * must be thread safe */
    va_list args;
//    setlogmask (LOG_UPTO (LOG_NOTICE));
#if defined DEBUG
    va_start(args, message);
    vprintf (message, args);
    va_end(args);
#else
    openlog (app_name, LOG_NDELAY | LOG_PID, LOG_USER);
#endif
    va_start(args, message);
    // get the clocktime and convert this to a string timestamp

    // do some sanity checking on the data

    // create the JSON from the data that's been passed in plus what's
    // already been populated in init_data like hostname and job_id

    // if we are aggregating, just push the data to an internal
    // stack and increment our aggregator until our threshold is reached.

    // else call the appropriate api (depending on macro def) to do the write

#if defined USE_SYSLOG
    SYSLOGGER(level, message, args);

#elif defined USE_RABBIT

#elif defined USE_LDMS

#elif defined USE_P2P

#endif
    va_end(args);
    return 0;
}

/* Placeholder for now. Will only develop if there is interest */
int daapLogRead(int keyval, int time_interval, int max_rows, char **row_array) {

    /* fopen the local log; */
    /* search for keyval and time_interval; */
    /* populate at most max_rows of row_array with results; */
    return 0;
}

